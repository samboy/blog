<div class=blogpic>
<img src=pics/2013-07-blog-square.jpg width=120 height=120>
</div>

<h1>My SipHash implementation</h1>
<h2>October 6, 2013</h2>
In 
<a href="http://samiam.org/blog/20131004.html">my last blog entry</a>, I mentioned
a fairly new cryptographic primitive called 
<a href="https://131002.net/siphash/">SipHash</a>.  Here, I will discuss
my implementation of SipHash, and how SipHash fixes yet another security
hole in unpatched DjbDNS 1.05.

<p>

<A name=My_SipHash_implementation></A><A name=MySipHashimplementation></A><span class=moyet>==</span><span class=blogtitle><b>My SipHash implementation</b></span><span class=moyet>==</span>

<p>

I now have 
<a href="http://samiam.org/software/DwSipHash-2013-10-06.tar.bz2">a tarball with my implementation</a>
of SipHash.  While there are many excellent public domain versions of
SipHash already out there (including the reference code), this 
implementation uses the same data types Deadwood’s strings use (making it
fairly easy to plug in to Deadwood), and is more extensible than other 
versions of SipHash.  In particular, I have used the code to make a
32-bit SipHash variant (SipHash uses 64-bit words).

<p>

<A name=S32Hash></A><A name=S32Hash></A><span class=moyet>==</span><span class=blogtitle><b>S32Hash</b></span><span class=moyet>==</span>

<p>

S32Hash is my own 32-bit variant of SipHash.  It generates a 32-bit hash
compression constant from a 64-bit key and a string of any length.  While
64 bits is really not quite long enough to be secure — a 64-bit key was
<a href="http://www.distributed.net/images/9/92/20020925_-_PR_-_64_bit_solved.pdf">brute force solved</a>
(PDF document) in a little under five years using thousands of computers 
in 2002 — it should be secure in cases where an attacker does not
have ready access to the compressed hash values (the normal case
when using it to determine the hash buckets to use).

<p>

The initial XOR constants to apply to the key are the top 32 bits of
the corresponding 64-bit constants:

<p>

<tt>32-bit <span class=pc>&nbsp;</span><span class=pc>&nbsp;</span>64-bit</tt><br>
<tt>736f6d65 736f6d6570736575</tt><br>
<tt>646f7261 646f72616e646f6d</tt><br>
<tt>6c796765 6c7967656e657261</tt><br>
<tt>74656462 7465646279746573</tt><br>

<p>

The rotation constants are simply the 64-bit rotation constants divided by
two, and rounded up:

<p>

<tt>64-bit 32-bit</tt><br>
<tt>13 <span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span>7</tt><br>
<tt>16 <span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span>8</tt><br>
<tt>32 <span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span>16</tt><br>
<tt>17 <span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span>9</tt><br>
<tt>21 <span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span>11</tt><br>
<tt>32 <span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span><span class=pc>&nbsp;</span>16</tt><br>

<p>

The first eight test vectors, where the key is 0x0001020304050607 and the
text to hash is {0-length string, 0x00, 0x0001, 0x000102, 0x00010203, etc.}:

<p>

<tt>9dd5acc0</tt><br>
<tt>8e478ea4</tt><br>
<tt>dfc77dc1</tt><br>
<tt>a41e0118</tt><br>
<tt>918a67d2</tt><br>
<tt>f3ba2c74</tt><br>
<tt>2b1691d7</tt><br>
<tt>a7e80642</tt><br>

<p>

There is 
<a href="http://samiam.org/software/DwS32Hash-2013-10-06.tar.bz2">a tarball</a> with
reference code for this SipHash variant.

<p>

If I ever use this code in Deadwood, I will change the key setup to,
instead of using a 64-bit key, initialize the four 32-bit values
with random numbers generated by Deadwood’s cryptographic pseudo
random number generator (PRNG).  To minimize the chance of a weak key,
I would make sure no single byte in the initial values has a 
value of 0.

<p>

The reason for this SipHash variant is because one of Deadwood’s
design goals is to run best on a 32-bit system.  For example, even though 
a 64-bit version of RadioGatún (Deadwood’s PRNG) exists, I use the 
32-bit version.

<p>

<A name=Yet_another_DjbDNS_security_hole></A><A name=YetanotherDjbDNSsecurityhole></A><span class=moyet>==</span><span class=blogtitle><b>Yet another DjbDNS security hole</b></span><span class=moyet>==</span>

<p>

Since DjbDNS was released before hash collision denial of service attacks
were well known (I myself didn’t think of them until designing and 
implementing Deadwood in 2007), it has a hash collision security hole:

<p>

<A href="https://00f.net/2012/06/26/dnscache-poisoning-and-siphash/">https://<![if gt IE 6]>&#8203;<![endif]><wbr>00<![if gt IE 6]>&#8203;<![endif]><wbr>f.<![if gt IE 6]>&#8203;<![endif]><wbr>net/<![if gt IE 6]>&#8203;<![endif]><wbr>2012/<![if gt IE 6]>&#8203;<![endif]><wbr>06/<![if gt IE 6]>&#8203;<![endif]><wbr>26/<![if gt IE 6]>&#8203;<![endif]><wbr>dnscache-<![if gt IE 6]>&#8203;<![endif]><wbr>poisoning-<![if gt IE 6]>&#8203;<![endif]><wbr>and-<![if gt IE 6]>&#8203;<![endif]><wbr>siphash/</A>

<p>

There is a patch:

<p>

<A href="http://download.pureftpd.org/misc/dnscache-siphash.patch">http://<![if gt IE 6]>&#8203;<![endif]><wbr>download.<![if gt IE 6]>&#8203;<![endif]><wbr>pureftpd.<![if gt IE 6]>&#8203;<![endif]><wbr>org/<![if gt IE 6]>&#8203;<![endif]><wbr>misc/<![if gt IE 6]>&#8203;<![endif]><wbr>dnscache-<![if gt IE 6]>&#8203;<![endif]><wbr>siphash.<![if gt IE 6]>&#8203;<![endif]><wbr>patch</A>

<p>

While DJB probably has too much pride to openly admit that he made a security
mistake with his 1990s hash compression algorithm, he has made up for this
security deficiency by kindly giving us SipHash.

<p>

I was aware that this part of djbdns’ code probably had a security issue
back in August of 2010, but did not follow up on my investigation.

<p>

<i>See also</i>
<a href="http://samiam.org/blog/20120711.html">Finally, a CVE-2012-1911 patch</a>
<a href="http://samiam.org/blog/20120314.html">The ghost domain bug</a>
<a href="http://samiam.org/blog/20110103.html">djbdns 1.05: False security</a>

<p>

<A name=MaraDNS_was_secure_first></A><A name=MaraDNSwassecurefirst></A><span class=moyet>==</span><span class=blogtitle><b>MaraDNS was secure first</b></span><span class=moyet>==</span>

<p>

Deadwood was secure against hash collision attacks back in 2007.  This
security was improved in 2010.  Even then, MaraDNS 1 was legacy code,
so I did not patch MaraDNS 1 until hash bucket collision attacks were more 
widely known in early 2012.  All of this preceded the publication 
of SipHash in the summer of 2012, and the above djbdns security
patch on
<a href="https://twitter.com/digdns/status/217864035981471744">July 27, 2012</a>.

<p>

<A name=Adding_SipHash_to_MaraDNS></A><A name=AddingSipHashtoMaraDNS></A><span class=moyet>==</span><span class=blogtitle><b>Adding SipHash to MaraDNS</b></span><span class=moyet>==</span>

<p>

As I mentioned before, while SipHash would improve Deadwood’s and
MaraDNS’ authoritative security, since the hash compression values
can not be readily seen by an attacker, the security improvement
would be an academic one.  I have to balance any security improvement
against the potential for increased code size and slower code.  And,
more to the point, MaraDNS is finished.  Since I never found a
good revenue stream for MaraDNS (besides its value as “Resume-ware”), 
development is now firmly on the back burner.
<p>

<i>Comments are closed.
</i>

<p>

<A href=/blog/>Blog index</A>

</div>
