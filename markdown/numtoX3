#!/bin/sh
_rem=--[=[
# POSIX shell wrapper to call correct version of Lua or Lunacy

LUNACY=""
if command -v lunacy64 >/dev/null 2>&1 ; then
  LUNACY=lunacy64
elif command -v lua5.1 >/dev/null 2>&1 ; then
  LUNACY=lua5.1
elif command -v lua-5.1 >/dev/null 2>&1 ; then
  LUNACY=lua-5.1
elif command -v lunacy >/dev/null 2>&1 ; then
  LUNACY=lunacy
elif command -v luajit >/dev/null 2>&1 ; then
  LUNACY=luajit # I assume luajit will remain frozen at Lua 5.1
fi
if [ -z "$LUNACY" ] ; then
  echo Please install Lunacy or Lua 5.1
  echo Either the version included with this blog -or- the version at
  echo https://github.com/samboy/lunacy
  echo To compile and install the version of Lunacy with the blog:
  echo
  echo     tar xvJf lunacy-2022-12-06.tar.xz
  echo     cd lunacy-2022-12-06/
  echo     make
  echo     sudo cp lunacy /usr/local/bin/
  exit 1
fi

exec $LUNACY $0 "$@"

# ]=]1
-- This script is written in Lua 5.1

-- This script has been donated to the public domain in 2025 by Sam Trenholme
-- If, for some reason, a public domain declation is not acceptable, it
-- may be licensed under the following terms:

-- Copyright 2025 Sam Trenholme
-- Permission to use, copy, modify, and/or distribute this software for
-- any purpose with or without fee is hereby granted.
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
-- WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
-- OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

-- Letâ€™s convert a UTF-8 character in to a low-bit control character
-- This uses obscure ASCII characters (Nul, \t, \n, \f, \r, and Esc
-- keep their meta-meeting) so that each character is 8 bits wide for
-- regex parsing etc.

function listArray(a)
  local out = ""
  for b=1,#a do
    out = out .. tostring(a[b]) .. " "
  end
  return out
end

-- This converts a number of arbitrary size in to a series of bytes
-- 0-191 as is
-- 192-4287 0b11XX_XXXX 0b10XX_XXXX, e.g. 192 is 0b1100_0000 0b1000_0000,
-- 193 is 0b1100_0000 0b1000_0001, and 4287 is 0b1111_1111 0b1011_1111,
-- 4288-266431 is 0b11XX_XXXX 0b11XX_XXXX 0b10XX_XXXX
-- 266432-17043647 is four bytes, starting with 0b11 0b11 0b11 0b10
-- etc. 

function numtoX3(n)
  if(n < 0) then return nil end -- Error
  local adder = 0
  local out = {}  
  local nsave = 0
  local adder = 192
  local power = 12
  nsave = n
  len = 1
  n = n - 192
  -- Pass one: How long is the string
  while n >= 0 do 
    n = n - 2^power
    if n >= 0 then
      adder = adder + 2^power
    end
    power = power + 6
    len = len + 1
  end
  n = nsave
  if n < 192 then
    out = {n}
  else
    n = n - adder
    out = {}
    for a=1,len do
      table.insert(out,1,n % 64)
      n = math.floor(n/64)
    end
  end
  outstr = ""
  if len > 1 then
    for a=1,#out do
      if(a < #out) then out[a] = out[a] + 192 
      else out[a] = out[a] + 128 end
      outstr = outstr .. string.char(out[a])
    end
  else
    outstr = string.char(out[1])
  end
  return outstr
end

if arg[1] == nil then arg[1] = 127 end
foo = numtoX3(tonumber(arg[1]))
print(foo) -- Run this through hexdump -C
