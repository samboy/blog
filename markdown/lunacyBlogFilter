#!/bin/sh
_rem=--[=[
# POSIX shell wrapper to call correct version of Lua or Lunacy

LUNACY=""
if command -v lunacy64 >/dev/null 2>&1 ; then
  LUNACY=lunacy64
elif command -v lua5.1 >/dev/null 2>&1 ; then
  LUNACY=lua5.1
elif command -v lua-5.1 >/dev/null 2>&1 ; then
  LUNACY=lua-5.1
elif command -v lunacy >/dev/null 2>&1 ; then
  LUNACY=lunacy
elif command -v luajit >/dev/null 2>&1 ; then
  LUNACY=luajit # I assume luajit will remain frozen at Lua 5.1
fi
if [ -z "$LUNACY" ] ; then
  echo Please install Lunacy or Lua 5.1
  echo Either the version included with this blog -or- the version at
  echo https://github.com/samboy/lunacy
  echo To compile and install the version of Lunacy with the blog:
  echo
  echo     tar xvJf lunacy-2022-12-06.tar.xz
  echo     cd lunacy-2022-12-06/
  echo     make
  echo     sudo cp lunacy /usr/local/bin/
  exit 1
fi

exec $LUNACY $0 "$@"

# ]=]1
-- This script is written in Lua 5.1

-- This script has been donated to the public domain in 2025 by Sam Trenholme
-- If, for some reason, a public domain declation is not acceptable, it
-- may be licensed under the following terms:

-- Copyright 2025 Sam Trenholme
-- Permission to use, copy, modify, and/or distribute this software for
-- any purpose with or without fee is hereby granted.
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
-- WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
-- OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

-- mc() converts a string in to a case insensitive regex; mc('th') is [Tt][Hh]
-- Do not use this when there are multiple letters in a regex class, i.e.
-- do not use this when the input has something like [dou] in it (any one of
-- d/o/u regex)
function mc(i)
  local out = ""
  local afterPercent = false
  for a=1,i:len() do
    seek = i:sub(a,a)
    -- Do not mangle anything right after a %
    if seek == "%" and not afterPercent then
      out = out .. seek
      afterPercent = true
    -- Only letters not after a % get mangled
    elseif seek:find("%a") and not afterPercent then
      out = out .. "[" .. seek:upper() .. seek:lower() .. "]"
    -- Other stuff is copied as is
    elseif seek and not afterPercent then
      out = out .. seek
    -- Everything right after a % is passed as-is
    elseif afterPercent then
      out = out .. seek
      afterPercent = false
    end
  end
  return out
end

-- Since Lunacy doesn't have split(), we make 
-- it ourselves
function Split(s, splitOn)
  if not splitOn then splitOn = "," end
  local place = true
  local out = {}
  local mark
  local last = 1
  while place do
    place, mark = string.find(s, splitOn, last, false)
    if place then
      table.insert(out,string.sub(s, last, place - 1))
      last = mark + 1
    end
  end
  table.insert(out,string.sub(s, last, -1))
  return out
end

-- Let’s convert a single glyph in to its UTF-8 form.  We will keep
-- &amp;, &lt;, and &gt for HTML compatibility
function entity2utf8(entity)
  local g={}
  -- Spanish letters
  g["&Aacute;"]='Á' g["&Eacute;"]='É' g["&Iacute;"]='Í' g["&Ntilde;"]='Ñ'
  g["&Oacute;"]='Ó' g["&Uacute;"]='Ú' g["&Uuml;"]='Ü'
  g["&aacute;"]='á' g["&eacute;"]='é' g["&iacute;"]='í' g["&ntilde;"]='ñ'
  g["&oacute;"]='ó' g["&uacute;"]='ú' g["&uuml;"]='ü' 
  -- Non-ASCII: Punctuation
  g["&mdash;"]='—' g["&lsquo;"]='‘' g["&rsquo;"]='’' g["&ldquo;"]='“'
  g["&rdquo;"]='”' g["&laquo;"]='«' g["&raquo;"]='»' g["&iexcl;"]='¡'
  g["&iquest;"]='¿' g["&copy;"]='©' g["&hearts;"]='♥' g["&rarr;"]='→'
  g["&bull;"]='•'

  if g[entity] then return g[entity] end
  return nil
end

-- Let’s convert a UTF-8 character in to a low-bit control character
-- This uses obscure ASCII characters (Nul, \t, \n, \f, \r, and Esc
-- keep their meta-meeting) so that each character is 8 bits wide for
-- regex parsing etc.
function utf8toXascii(glyph)
  local g={}
  --[[ NUL ]]    g["Á"] = '\1'  g["É"] = '\2'  g["Í"] = '\3' 
  g["Ñ"] = '\4'  g["Ó"] = '\5'  g["Ú"] = '\6'  g["Ü"] = '\7'
  g["¡"] = '\8'  --[[ \t ]]     --[[ \n ]]     g["•"] = '\11'
  --[[ \f ]]     --[[ \r ]]     g["«"] = '\14' g["»"] = '\15'
  g["—"] = '\16' g["á"] = '\17' g["é"] = '\18' g["í"] = '\19'
  g["ñ"] = '\20' g["ó"] = '\21' g["ú"] = '\22' g["ü"] = '\23'
  g["¿"] = '\24' g["‘"] = '\25' g["’"] = '\26' --[[ ESC ]]
  g["→"] = '\28' g["“"] = '\29' g["”"] = '\30' g["©"] = '\31'
  g["♥"] = '\127'

  if g[glyph] then return g[glyph] end
  return nil
end

function Xascii2utf8(glyph) 
  g={}
  g["\1"] = "Á" g["\2"] = "É" g["\3"] = "Í" g["\4"] = "Ñ" g["\5"] = "Ó" 
  g["\6"] = "Ú" g["\7"] = "Ü" g["\8"] = "¡" g["\11"] = "•" 
  g["\14"] = "«" g["\15"] = "»" g["\16"] = "—" g["\17"] = "á" 
  g["\18"] = "é" g["\19"] = "í" g["\20"] = "ñ" g["\21"] = "ó" 
  g["\22"] = "ú" g["\23"] = "ü" g["\24"] = "¿" g["\25"] = "‘" 
  g["\26"] = "’" g["\28"] = "→" g["\29"] = "“" g["\30"] = "”" 
  g["\31"] = "©" g["\127"] = "♥"

  if(g[glyph]) then return g[glyph] end
  return glyph
end

-- Let’s determine how wide each and every character is in the Roboto
-- Serif variant font I use for my blog. Since I only have a small superset
-- of ASCII, I can do this.
-- Glyph can either be an ASCII character (except '<', '>', or '&') or
-- an HTML entity (e.g. '&amp;'). This function will raise an error if 
-- a character not in my special subset of Roboto Serif is used as its
-- argument.
function width(glyph) 
  -- Letters
  local g = {A=707, B=698, C=762, D=784, E=694, F=666, G=810, H=842, I=408,
             J=649, K=766, L=642, M=969, N=817, O=799, P=678, Q=799, R=744,
             S=646, T=713, U=803, V=729, W=1014, X=744, Y=696, Z=661,
             a=601, b=668, c=572, d=677, e=580, f=448, g=673, h=682, i=340,
             j=338, k=681, l=347, m=990, n=682, o=630, p=691, q=668, r=474,
             s=531, t=463, u=671, v=649, w=938, x=659, y=662, z=541}
  -- Rest of ASCII
  g[" "] = 257 g["0"] = 560 g["1"] = 560 g["2"] = 560 g["3"] = 560
  g["4"] = 560 g["5"] = 560 g["6"] = 560 g["7"] = 560 g["8"] = 560
  g["9"] = 560 g["_"] = 529 g["-"] = 479 g["("] = 408 g[")"] = 408
  g["["] = 396 g["]"] = 396 g["{"] = 454 g["}"] = 454 g["#"] = 752
  g["%"] = 752 g["'"] = 252 g['"'] = 457 g["*"] = 519 g["."] = 306
  g[","] = 330 g[":"] = 306 g[";"] = 330 g["!"] = 326 g["?"] = 555
  g["/"] = 583 g["\\"]= 583 g["@"] = 960 g["+"] = 560 g["-"] = 560
  g["="] = 560 g["$"] = 560 g["^"] = 523 g["~"] = 521 g["|"]=267
  -- ASCII with special meaning in HTML
  g["&amp;"]=765 g["&lt;"]=560 g["&gt;"]=560
  -- Non-ASCII: Spanish letters
  g["&Aacute;"]=707 g["&Eacute;"]=694 g["&Iacute;"]=408 g["&Ntilde;"]=817
  g["&Oacute;"]=799 g["&Uacute;"]=803 g["&Uuml;"]=803
  g["&aacute;"]=601 g["&eacute;"]=580 g["&iacute;"]=340 g["&ntilde;"]=682
  g["&oacute;"]=630 g["&uacute;"]=671 g["&uuml;"]=671 
  -- Non-ASCII: Punctuation
  g["&mdash;"]=1002 g["&lsquo;"]=286 g["&rsquo;"]=286 g["&ldquo;"]=528
  g["&rdquo;"]=528 g["&laquo;"]=635 g["&raquo;"]=635 g["&iexcl;"]=326
  g["&iquest;"]=555 g["&copy;"]=870 g["&hearts;"]=905 g["&rarr;"]=840
  g["&bull;"]=497

  if g[glyph] == nil then
    print("Fatal error: Invalid glyph " ..glyph.. " in source md file")
    os.exit(2)
  end
  return g[glyph]
end

-- Given a line, split any words (or URLs) too wide to fit on a single line
-- of a 320 pixel small smartphone (iPhone mini, etc.) 
-- Input: Mostly processed HTML with wide words
-- Output: String with wide words split
function splitWideWords(l) 
  -- We use this ugly monstrosity so it works with pretty much any browser
  -- Yes, I remember the IE6 days and still have weird habits from that era
  local splitString = "<![if gt IE 6]>&#8203;<![endif]><wbr>"
  local outString = ""
  local thisGlyph = ""
  local currentWidth = 0
  local inTag = false
  a = 1
  while a <= l:len() do
    local look = l:sub(a,a)
    if(look == '<') then
      inTag = true
    end
    thisGlyph = look
    if(look == '&') then
      while(look ~= ';' and a < l:len()) do
        a = a + 1
        look = l:sub(a,a)
        thisGlyph = thisGlyph .. look
      end
      a = a + 1
      if(a > l:len() and l:sub(l:len(),l:len()) ~= ';') then
        outString = outString .. thisGlyph
        return outString
      end
    else
      a = a + 1
    end
    if(thisGlyph:find('%s') and not inTag) then
      currentWidth = 0
      outString = outString .. thisGlyph
    elseif(not inTag) then
      currentWidth = currentWidth + width(thisGlyph)
      if currentWidth > 18000 then -- 18 “m”s roughly
        currentWidth = 0
        outString = outString .. splitString
      end
      outString = outString .. thisGlyph
    elseif(inTag) then
      outString = outString .. thisGlyph
    end
    if(look == '>') then
      inTag = false
    end
  end
  return outString
end

globalInWidePic = false
globalCaption = ""
globalBlogDate = arg[1]
if not globalBlogDate then
  globalBlogDate = os.time()
end
globalSupString = 
          '<sup style="font-size: 10pt; line-height: 0; vertical-align: 6px">'
globalFootnotes = {}

-- Footnotes
function processFootnotes()
  if(#globalFootnotes > 0) then
    if(#globalFootnotes == 1) then 
      print "<h3>Footnote</h3>" 
    else
      print "<h3>Footnotes</h3>" 
    end
    for f=1,#globalFootnotes do
      local body = globalFootnotes[f]['body']
      -- Allow bare links in footnotes
      body=body:gsub(mc('(https://%S+)'),'<a href="%1">%1</a>')
      print('<a name="' .. globalFootnotes[f]['name'] .. '"> </a>')
      print('<a href="#back-' .. globalFootnotes[f]['name'] .. '">')
      print(globalFootnotes[f]['link'] .. '</a>: ' .. body)
      print("<p>\n")
    end
  end
end

-- Process any <a id> stuff in the HTML after processing pictures in the
-- blog. Also processes simple subscripts
function processIDetc(l)
  -- If convenient, make <a id> <a name="foo"> </a>
  -- This way the blog can have bookmarks linking directly to sections
  if l:find(mc('<h3>.*<a id="([^"]+)"[^"]*$')) then
    local thisID = l
    thisID = thisID:gsub('^.*<a id="','')
    thisID = thisID:gsub('"[^"]*$','')
    if(globalBlogDate and globalBlogDate ~= "") then
      thisID = globalBlogDate .. '-' .. thisID
    else
      thisID = os.time() .. '-' .. thisID
    end 
    print('<a name="' .. thisID .. '"> </a>')
  end
  -- Remove <a id> stuff; it messes up the formatting of the blog on my
  -- web page
  l = l:gsub(mc('<a id[^>]+>'),'')
  l = l:gsub(mc('</a>(</h%d>)'),'%1')
  -- While we’re at it, we don’t need </p> in the document
  l = l:gsub(mc('</p>'),'')
  -- And, oh, let’s process superscripts
  l = l:gsub('([A-Za-z0-9])%^([A-Za-z0-9]+)', 
             '%1' .. globalSupString .. "%2" .. "</sup>")
  -- htmldoc is buggy with italics in quotes
  l = l:gsub('%;_([a-zA-Z0-9]+)_%&',';<i>%1</i>&')
  -- Remove whitespace after <a href
  l = l:gsub(mc('(<a href=[^>]+>)%s+'),"%1")
  -- Footnotes
  if(l:find(mc('<a href=\"fn:'))) then
    local footnoteIndex = #globalFootnotes + 1
    local name = l
    name = name:gsub(mc('.*<a href=\"fn:([^<]*).*'),'%1')
    local linkText = name
    local fnText = name
    name = name:gsub('([^"]*)".*','%1')
    linkText = linkText:gsub(mc('[^>]*>%^?(%S+).*$'),'%1')
    fnText = fnText:gsub(mc('[^>]*%^?%S+([^<]+).*$'),'%1')
    globalFootnotes[footnoteIndex] = {}
    name = globalBlogDate .. '-' .. name
    globalFootnotes[footnoteIndex]['name'] = name
    globalFootnotes[footnoteIndex]['link'] = linkText
    globalFootnotes[footnoteIndex]['body'] = fnText
    l = l:gsub(mc('<a href=\"fn:[^>]*>[^<]*</a>'),
        globalSupString .. 
        '<a id="back-' .. name .. '">' ..
        '<a href="#' .. name .. '">' .. linkText .. '</a></a></sup>')
  end
  -- Break long words
  l = splitWideWords(l)
  print(l)
end

-- After processing the picture on top of the blog, process any pictures
-- inside the blog
function processWidePic(l)
  if(l:find(mc('img alt="widepic"'))) then
    local lp = l:gsub("^%s+","")
    local fields=Split(lp,"%s+")
    if(fields[3]) then
      globalCaption = ""
      local pic = fields[3]
      pic = pic:gsub('^[^"]*"','',1)
      pic = pic:gsub('"[^"]*$','',1)
      if(#fields > 3) then
        for a=4,#fields do
          globalCaption = globalCaption .. fields[a] .. " "
        end
      end
      print('<img class=widepic src="' .. pic .. '" alt="">') 
      print('<br class=nomobile>')
      globalInWidePic = true
    end
  elseif(globalInWidePic) then
    print(globalCaption)
    processIDetc(l)
    globalInWidePic = false
    globalCaption = ""
  else 
    processIDetc(l)
  end
end

-- After we have filtered out all lines before the second HR NOSHADE,
-- process the line further
-- In this step, we process the image for the blog entry at the top
-- Input: A single line we are processing
-- Output: None (print called in function)
function processStep2(l)
  if(l:find(mc('img alt="blogpic"'))) then
    local lp = l:gsub("^%s+","")
    local fields=Split(lp,"%s+")
    if(fields[3]) then
      local pic = fields[3]
      pic = pic:gsub('^[^"]*"','',1)
      pic = pic:gsub('"[^"]*$','',1)
      print('<div class=blogpicx style="text-align: right">')
      print('<img src="' .. pic .. '" width=224 height=126>')
      print('</div>')
    else
      processWidePic(l)
    end
  else
    processWidePic(l)
  end 
end  

globalPlaceMarker = 0
-- Step one: Print nothing until after second HR NOSHADE
function processStep1(l) 
  l = l:gsub('%s+</a>','</a>') -- Spaces before link close look bad
  l = l:gsub('</h2>%s*<p>',"</h2>\n") -- No <p> after <h2>; legacy blog issue
  -- Do not show anything until after the *second* “HR NOSHADE”
  if globalPlaceMarker == 2 then processStep2(l) end
  if(l:find(mc("HR NOSHADE"))) then 
    globalPlaceMarker = globalPlaceMarker + 1 
  end
end

-- This code is a fairly complicated state machine:
-- * HTML tags are always on the same line so we can process them
-- * HTML links are always on the same line so we can process them
-- * DOS linefeed characters are stripped
inLink = false
inTag = false
currentLine = ""
currentState = 0
repeat
  l = io.read(1)
  if not l then processStep1(currentLine) break end
  if l == "\r" then l = io.read(1) 
  elseif l == "\n" and not inLink and not inTag then
    processStep1(currentLine)
    currentLine = ""
  elseif l == '<' and currentState == 0 then
    inTag = true
    currentLine = currentLine .. l
    currentState = 1
  elseif l == '/' and currentState == 1 then
    currentLine = currentLine .. l
    currentState = 100
  -- Process end of links
  elseif l == 'a' and currentState == 100 then
    currentLine = currentLine .. l
    currentState = 101
  elseif l == '>' and currentState == 101 then
    currentLine = currentLine .. l
    currentState = 102
    inLink = false
    inTag = false
  elseif l == '<' and currentState == 102 then
    currentLine = currentLine .. l
    currentState = 1
    inTag = true
  elseif l:find('%S') and currentState == 102 then
    currentLine = currentLine .. l
  elseif l:find('%s') and currentState == 102 then
    currentState = 0
    processStep1(currentLine)
    currentLine = ""
  -- Process h2 tags
  elseif l == 'h' and currentState == 100 then
    currentLine = currentLine .. l
    currentState = 200
  elseif l == '2' and currentState == 200 then
    currentLine = currentLine .. l
    currentState = 201
  elseif l == '>' and currentState == 201 then
    currentLine = currentLine .. l
    currentState = 0
    inTag = true -- Keep this true so the subsequent <p> is on same line
  elseif l == 'a' and currentState == 1 then
    currentLine = currentLine .. l
    currentState = 2
  elseif l:find('%s') and currentState == 2 then
    currentLine = currentLine .. ' '
  elseif l == 'h' and currentState == 2 then
    currentLine = currentLine .. l
    currentState = 3
  elseif l == 'r' and currentState == 3 then
    currentLine = currentLine .. l
    currentState = 4
  elseif l == 'e' and currentState == 4 then
    currentLine = currentLine .. l
    currentState = 5
  elseif l == 'f' and currentState == 5 then
    currentLine = currentLine .. l
    currentState = 6
  elseif l == '=' and currentState == 6 then
    currentLine = currentLine .. l
    currentState = 0
    inLink = true
  elseif l == "\n" and inLink then
    currentLine = currentLine .. ' '
  elseif l == "\n" and inTag then
    currentLine = currentLine .. ' '
  elseif l == '>' then
    inTag = false
    currentLine = currentLine .. l
    currentState = 0
  elseif l then
    currentLine = currentLine .. l
    currentState = 0
  end
until not l

-- Show any remaining footnotes
processFootnotes()

-- Footer
print ""
print "<p>"
print ""
print "<A href=/blog/>Blog index</A>"
print ""
print "</div>"
print ""
