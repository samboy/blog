#!/bin/sh
pureASCIIoutput=false
x80emdash=false
blogFooter=true
_rem=--[=[
# This script converts the output of HTML doc (1.9.16) in to HTML suitable
# for putting on my blog.
#
# Above are flags which affect how the code runs
# pureASCIIoutput: false if you want the blog to output UTF-8
#             true if you want to instead use HTML entities and pure ASCII
# x80emdash: true means we treat 0x80 (\128) as if it were an emdash
#            false means we get HTML entities or pure Xascii as input.
#            In both cases, the input is Xascii/HTML entities and not UTF-8
# blogfooter: Whether to have the blog footer in the generated HTML
# POSIX shell wrapper to call correct version of Lua or Lunacy

LUNACY=""
if command -v lunacy64 >/dev/null 2>&1 ; then
  LUNACY=lunacy64
elif command -v lua5.1 >/dev/null 2>&1 ; then
  LUNACY=lua5.1
elif command -v lua-5.1 >/dev/null 2>&1 ; then
  LUNACY=lua-5.1
elif command -v lunacy >/dev/null 2>&1 ; then
  LUNACY=lunacy
elif command -v luajit >/dev/null 2>&1 ; then
  LUNACY=luajit # I assume luajit will remain frozen at Lua 5.1
fi
if [ -z "$LUNACY" ] ; then
  echo Please install Lunacy or Lua 5.1
  echo Either the version included with this blog -or- the version at
  echo https://github.com/samboy/lunacy
  echo To compile and install the version of Lunacy with the blog:
  echo
  echo     tar xvJf lunacy-2022-12-06.tar.xz
  echo     cd lunacy-2022-12-06/
  echo     make
  echo     sudo cp lunacy /usr/local/bin/
  exit 1
fi

exec $LUNACY $0 "$@"

# ]=]1
-- This script is written in Lua 5.1

-- This script has been donated to the public domain in 2025 by Sam Trenholme
-- If, for some reason, a public domain declation is not acceptable, it
-- may be licensed under the following terms:

-- Copyright 2025 Sam Trenholme
-- Permission to use, copy, modify, and/or distribute this software for
-- any purpose with or without fee is hereby granted.
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
-- WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
-- OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

-- mc() is a regex processing engine. For non-ASCII, it assumes to be using
-- my own Xascii format (a 7-bit representsation of characters in the subset
-- of Roboto Serif I use for my blog)
-- A few new character classes are used:

-- '%b' is blank space ('%s' includes the — em dash character)
-- '%B' is not blank space
-- '%g' (“Grande”) is all uppercase letters ('%u' is ASCII only)
-- '%G' is everything except uppercase letters
-- '%m' (“mini”) is all lowercase letters ('%l' is ASCII only)
-- '%M' is everything except lowercase letters
-- '%r' (“read”) is alphanumeric ('%w' is ASCII only)
-- '%R' is everything except alphanumeric
-- '%t' (“total”) is all letters ('%a' is ASCII only)
-- '%T' is everything except letters

-- Do *NOT* use these new classes inside of [] brackets

-- Also converts a string in to a case insensitive regex; mc('th') is [Tt][Hh]
-- Do not use this when there are multiple letters in a regex class, i.e.
-- do not use this when the input has something like [dou] in it (any one of
-- d/o/u regex)
function mc(i)
  local out = ""
  local afterPercent = false
  local bl = '['
  local br = ']'
  for a=1,i:len() do
    seek = i:sub(a,a)
    -- Do not mangle anything right after a %
    if seek == "%" and not afterPercent then
      afterPercent = true
    -- Allow letters and new (lower case) classes inside brackets
    elseif seek == '[' then
      bl = ''
      br = ''
      out = out .. seek
    elseif seek == ']' then
      bl = '['
      br = ']'
      out = out .. seek
    -- Only letters not after a % get mangled
    elseif seek:find("%a") and not afterPercent then
      out = out .. bl .. seek:upper() .. seek:lower() .. br
    -- Other stuff is copied as is
    elseif seek and not afterPercent then
      out = out .. seek
    -- Everything right after a % is passed as-is
    elseif afterPercent then
      if seek == 'b' then -- Blank
        out = out .. bl .. '\r\n\t\f ' .. br
      elseif seek == 'B' then
        out = out .. '[^\r\n\t\f ]'
      elseif seek == 'g' then -- Uppercase (“grande”)
        out = out .. bl .. 'A-Z\1-\7' .. br
      elseif seek == 'G' then
        out = out .. '[^A-Z\1-\7]'
      elseif seek == 'm' then -- Lowercase (“mini”)
        out = out .. bl .. 'a-z\17-\23' .. br
      elseif seek == 'M' then
        out = out .. '[^a-z\17-\23]'
      elseif seek == 'r' then -- Alphanumeric (“read”)
        out = out .. bl .. 'A-Za-z0-9\1-\7\17-\23' .. br
      elseif seek == 'R' then 
        out = out .. '[^A-Za-z0-9\1-\7\17-\23]'
      elseif seek == 't' then -- All letters (“total”)
        out = out .. bl .. 'A-Za-z\1-\7\17-\23' .. br
      elseif seek == 'T' then 
        out = out .. '[^A-Za-z\1-\7\17-\23]'
      else
        out = out .. "%" .. seek
      end
      afterPercent = false
    end
  end
  return out
end

-- Since Lunacy doesn't have split(), we make 
-- it ourselves
function Split(s, splitOn)
  if not splitOn then splitOn = "," end
  local place = true
  local out = {}
  local mark
  local last = 1
  while place do
    place, mark = string.find(s, splitOn, last, false)
    if place then
      table.insert(out,string.sub(s, last, place - 1))
      last = mark + 1
    end
  end
  table.insert(out,string.sub(s, last, -1))
  return out
end

-- We need to go through tables in sorted order sometimes
-- Like pairs() but sorted
-- This assumes all keys are of the same type
function sPairs(inputTable)
  local keyList = {}
  local index = 1
  for k,_ in pairs(inputTable) do
    table.insert(keyList,k)
  end
  table.sort(keyList)
  return function()
    rvalue = keyList[index]
    index = index + 1
    return rvalue, inputTable[rvalue]
  end
end

-- CONVERSTION ROUTINES --
-- These are a bunch of routines which convert between three forms
-- of expressing non-ASCII characters:
-- 1. HTML entities (e.g. "&hearts;") which htmldoc uses
-- 2. UTF-8 which is a lot more readable than HTML entities
-- 3. Xascii, which is a special 7-bit representation of non-ASCII
-- 
-- The reason we use Xascii is because Lunacy’s regex engine is 8-bit
-- and we want to be able to process non-ASCII easily.
-- Xascii is never stored in a file, and is as follows:

--   0123456789abcdef
-- 0 .ÁÉÍÑÓÚÜ¡..—..«»
-- 1 •áéíñóúü¿‘’.→“”©
-- 2 .!"#$%&'()*+,-./
-- 3 0123456789:;<=>?
-- 4 @ABCDEFGHIJKLMNO
-- 5 PQRSTUVWXYZ[\]^_
-- 6 `abcdefghijklmno
-- 7 pqrstuvwxyz{|}~♥
-- 
-- Non-printable chars (rendered as .)
-- 0x00 is Null (end of string)
-- 0x09 is Tab
-- 0x0a (\10) is Newline
-- 0x0c (\12) is Form feed
-- 0x0d (\13) is CR (used in DOS linefeeds)
-- 0x1b (\14) is Escape
-- 0x20 (\32) is space
-- 
-- Also:
-- 
-- 0x0b (\11) is em dash (—)
-- 0x19 (\25) is left smart single quote (‘)
-- 0x1a (\26) is right smart quote (’)
-- 0x1d (\29) is left smart double quote (“)
-- 0x1e (\30) is right smart double quote (”)
-- 0x2d is ASCII dash (-)
-- 0x2e is ASCII period (.)

-- Let’s convert a single glyph in to its UTF-8 form.  We will keep
-- &amp;, &lt;, and &gt for HTML compatibility
function entity2utf8(entity)
  local g={}
  -- Spanish letters
  g["&Aacute;"]='Á' g["&Eacute;"]='É' g["&Iacute;"]='Í' g["&Ntilde;"]='Ñ'
  g["&Oacute;"]='Ó' g["&Uacute;"]='Ú' g["&Uuml;"]='Ü'
  g["&aacute;"]='á' g["&eacute;"]='é' g["&iacute;"]='í' g["&ntilde;"]='ñ'
  g["&oacute;"]='ó' g["&uacute;"]='ú' g["&uuml;"]='ü' 
  -- Non-ASCII: Punctuation
  g["&mdash;"]='—' g["&lsquo;"]='‘' g["&rsquo;"]='’' g["&ldquo;"]='“'
  g["&rdquo;"]='”' g["&laquo;"]='«' g["&raquo;"]='»' g["&iexcl;"]='¡'
  g["&iquest;"]='¿' g["&copy;"]='©' g["&hearts;"]='♥' g["&rarr;"]='→'
  g["&bull;"]='•' 
  -- ASCII
  g["&quot;"] = '"'
  -- Preserve entities which are metachars in HTML
  g["&lt;"] = "&lt;" g["&gt;"] = "&gt;" g["&amp;"] = "&amp;"

  if g[entity] then return g[entity] end
  return nil
end

-- Let’s convert an entity in to my Xascii format
function entity2Xascii(entity)
  local g = {} 
  -- non-ASCII
  g["&Aacute;"] = "\1" g["&Eacute;"] = "\2" g["&Iacute;"] = "\3"
  g["&Ntilde;"] = "\4" g["&Oacute;"] = "\5" g["&Uacute;"] = "\6"
  g["&Uuml;"] = "\7" g["&iexcl;"] = "\8" g["&mdash;"] = "\11" 
  g["&laquo;"] = "\14" g["&raquo;"] = "\15" g["&bull;"] = "\16" 
  g["&aacute;"] = "\17" g["&eacute;"] = "\18" g["&iacute;"] = "\19" 
  g["&ntilde;"] = "\20" g["&oacute;"] = "\21" g["&uacute;"] = "\22" 
  g["&uuml;"] = "\23" g["&iquest;"] = "\24" g["&lsquo;"] = "\25" 
  g["&rsquo;"] = "\26" g["&rarr;"] = "\28" g["&ldquo;"] = "\29" 
  g["&rdquo;"] = "\30" g["&copy;"] = "\31" g["&hearts;"] = "\127"
  -- ASCII
  g["&quot;"] = '"'
  -- Preserve entities which are metachars in HTML
  g["&lt;"] = "&lt;" g["&gt;"] = "&gt;" g["&amp;"] = "&amp;"

  if g[entity] then return g[entity] end
  return "\16"
end

-- Convert Xascii in to an entity
function Xascii2entity(glyph)
  local g={}
  g["\1"]="&Aacute;" g["\2"]="&Eacute;" g["\3"]="&Iacute;"
  g["\4"]="&Ntilde;" g["\5"]="&Oacute;" g["\6"]="&Uacute;" g["\7"]="&Uuml;"
  g["\8"]="&iexcl;" g["\11"]="&mdash;" g["\14"]="&laquo;" g["\15"]="&raquo;"
  g["\16"]="&bull;" g["\17"]="&aacute;" g["\18"]="&eacute;"
  g["\19"]="&iacute;" g["\20"]="&ntilde;" g["\21"]="&oacute;"
  g["\22"]="&uacute;" g["\23"]="&uuml;" g["\24"]="&iquest;"
  g["\25"]="&lsquo;" g["\26"]="&rsquo;" g["\28"]="&rarr;" g["\29"]="&ldquo;"
  g["\30"]="&rdquo;" g["\31"]="&copy;" g["\127"]="&hearts;"
  
  if g[glyph] then return g[glyph] end
  return glyph
end

-- Let’s convert a UTF-8 character in to a low-bit control character
-- This uses obscure ASCII characters (Nul, \t, \n, \f, \r, and Esc
-- keep their meta-meeting) so that each character is 8 bits wide for
-- regex parsing etc.
function utf8toXascii(glyph)
  local g={}
  --[[ NUL ]]    g["Á"] = '\1'  g["É"] = '\2'  g["Í"] = '\3' 
  g["Ñ"] = '\4'  g["Ó"] = '\5'  g["Ú"] = '\6'  g["Ü"] = '\7'
  g["¡"] = '\8'  --[[ \t ]]     --[[ \n ]]     g["—"] = '\11'
  --[[ \f ]]     --[[ \r ]]     g["«"] = '\14' g["»"] = '\15'
  g["•"] = '\16' g["á"] = '\17' g["é"] = '\18' g["í"] = '\19'
  g["ñ"] = '\20' g["ó"] = '\21' g["ú"] = '\22' g["ü"] = '\23'
  g["¿"] = '\24' g["‘"] = '\25' g["’"] = '\26' --[[ ESC ]]
  g["→"] = '\28' g["“"] = '\29' g["”"] = '\30' g["©"] = '\31'
  g["♥"] = '\127'

  if g[glyph] then return g[glyph] end
  return nil
end

function Xascii2utf8(glyph) 
  g={}
  g["\1"] = "Á" g["\2"] = "É" g["\3"] = "Í" g["\4"] = "Ñ" g["\5"] = "Ó" 
  g["\6"] = "Ú" g["\7"] = "Ü" g["\8"] = "¡" g["\11"] = "—" 
  g["\14"] = "«" g["\15"] = "»" g["\16"] = "•" g["\17"] = "á" 
  g["\18"] = "é" g["\19"] = "í" g["\20"] = "ñ" g["\21"] = "ó" 
  g["\22"] = "ú" g["\23"] = "ü" g["\24"] = "¿" g["\25"] = "‘" 
  g["\26"] = "’" g["\28"] = "→" g["\29"] = "“" g["\30"] = "”" 
  g["\31"] = "©" g["\127"] = "♥"

  if(g[glyph]) then return g[glyph] end
  return glyph
end

-- Convert Xascii string in to utf-8 (or pure ASCII with HTML entities)
function XasciiStringConvert(l)
  l = tostring(l)
  local out = ""
  for a=1,l:len() do
    if pureASCIIoutput then
      out = out .. Xascii2entity(l:sub(a,a))
    else -- UTF-8 in output
      out = out .. Xascii2utf8(l:sub(a,a))
    end
  end
  return out
end

-- Let’s determine how wide each and every character is in the Roboto
-- Serif variant font I use for my blog. Since I only have a small superset
-- of ASCII, I can do this.
-- Glyph can either be an ASCII character (except '<', '>', or '&') or
-- an HTML entity (e.g. '&amp;') or an Xascii character. This function will 
-- raise an error if a character not in my special subset of Roboto Serif 
-- is used as its argument.
function width(glyph) 
  -- Letters
  local g = {A=707, B=698, C=762, D=784, E=694, F=666, G=810, H=842, I=408,
             J=649, K=766, L=642, M=969, N=817, O=799, P=678, Q=799, R=744,
             S=646, T=713, U=803, V=729, W=1014, X=744, Y=696, Z=661,
             a=601, b=668, c=572, d=677, e=580, f=448, g=673, h=682, i=340,
             j=338, k=681, l=347, m=990, n=682, o=630, p=691, q=668, r=474,
             s=531, t=463, u=671, v=649, w=938, x=659, y=662, z=541}
  -- Rest of ASCII
  g[" "] = 257 g["0"] = 560 g["1"] = 560 g["2"] = 560 g["3"] = 560
  g["4"] = 560 g["5"] = 560 g["6"] = 560 g["7"] = 560 g["8"] = 560
  g["9"] = 560 g["_"] = 529 g["-"] = 479 g["("] = 408 g[")"] = 408
  g["["] = 396 g["]"] = 396 g["{"] = 454 g["}"] = 454 g["#"] = 752
  g["%"] = 752 g["'"] = 252 g['"'] = 457 g["*"] = 519 g["."] = 306
  g[","] = 330 g[":"] = 306 g[";"] = 330 g["!"] = 326 g["?"] = 555
  g["/"] = 583 g["\\"]= 583 g["@"] = 960 g["+"] = 560 g["-"] = 560
  g["="] = 560 g["$"] = 560 g["^"] = 523 g["~"] = 521 g["|"] = 267
  g["`"] = 482
  -- ASCII with special meaning in HTML
  g["&amp;"]=765 g["&lt;"]=560 g["&gt;"]=560
  -- Non-ASCII: Spanish letters
  g["&Aacute;"]=707 g["&Eacute;"]=694 g["&Iacute;"]=408 g["&Ntilde;"]=817
  g["&Oacute;"]=799 g["&Uacute;"]=803 g["&Uuml;"]=803
  g["&aacute;"]=601 g["&eacute;"]=580 g["&iacute;"]=340 g["&ntilde;"]=682
  g["&oacute;"]=630 g["&uacute;"]=671 g["&uuml;"]=671 
  -- Non-ASCII: Punctuation
  g["&mdash;"]=1002 g["&lsquo;"]=286 g["&rsquo;"]=286 g["&ldquo;"]=528
  g["&rdquo;"]=528 g["&laquo;"]=635 g["&raquo;"]=635 g["&iexcl;"]=326
  g["&iquest;"]=555 g["&copy;"]=870 g["&hearts;"]=905 g["&rarr;"]=840
  g["&bull;"]=497

  -- Xascii
  g["\1"] = 707 g["\2"] = 694 g["\3"] = 408 g["\4"] = 817 g["\5"] = 799
  g["\6"] = 803 g["\7"] = 803 g["\8"] = 326 g["\11"] = 1002 g["\14"] = 635
  g["\15"] = 635 g["\16"] = 497 g["\17"] = 601 g["\18"] = 580 
  g["\19"] = 340 g["\20"] = 682 g["\21"] = 630 g["\22"] = 671 
  g["\23"] = 671 g["\24"] = 555 g["\25"] = 286 g["\26"] = 286 
  g["\28"] = 840 g["\29"] = 528 g["\30"] = 528 g["\31"] = 870 
  g["\127"] = 905

  if g[glyph] == nil then
    print("Fatal error: Invalid glyph " ..glyph.. " in source md file")
    os.exit(2)
  end
  return g[glyph]
end

-- Given a line, split any words (or URLs) too wide to fit on a single line
-- of a 320 pixel small smartphone (iPhone mini, etc.) 
-- Input: Mostly processed HTML with wide words
-- Output: String with wide words split
function splitWideWords(l) 
  -- We use this ugly monstrosity so it works with pretty much any browser
  -- Yes, I remember the IE6 days and still have weird habits from that era
  local splitString = "<![if gt IE 6]>&#8203;<![endif]><wbr>"
  local outString = ""
  local thisGlyph = ""
  local currentWidth = 0
  local inTag = false
  a = 1
  while a <= l:len() do
    local look = l:sub(a,a)
    if(look == '<') then
      inTag = true
    end
    thisGlyph = look
    if(look == '&') then
      while(look ~= ';' and a < l:len()) do
        a = a + 1
        look = l:sub(a,a)
        thisGlyph = thisGlyph .. look
      end
      a = a + 1
      if(a > l:len() and l:sub(l:len(),l:len()) ~= ';') then
        outString = outString .. thisGlyph
        return outString
      end
    else
      a = a + 1
    end
    -- Emdash does split lines so it’s allowed as a “whitespace” char
    if(thisGlyph:find('%s') and not inTag) then
      currentWidth = 0
      outString = outString .. thisGlyph
    elseif(thisGlyph:find('%/') and not inTag) then
      currentWidth = 0
      outString = outString .. thisGlyph
      outString = outString .. splitString
    elseif(not inTag) then
      currentWidth = currentWidth + width(thisGlyph)
      if currentWidth > 15000 then -- 18 “m”s roughly
        currentWidth = 0
        outString = outString .. splitString
      end
      outString = outString .. thisGlyph
    elseif(inTag) then
      outString = outString .. thisGlyph
    end
    if(look == '>') then
      inTag = false
    end
  end
  return outString
end

globalInWidePic = false
globalCaption = ""
globalBlogDate = arg[1]
if not globalBlogDate then
  globalBlogDate = os.time()
end
globalSupString = 
          '<sup style="font-size: 10pt; line-height: 0; vertical-align: 6px">'
globalFootnotes = {}

-- Footnotes
function processFootnotes()
  local x = XasciiStringConvert
  -- In a more enlightened world, 'text-indent: -1.1em hanging' would work
  -- on Chrome and Edge
  local style = 'margin-left: 1.1em;text-indent: -1.1em;'
  -- Show footnotes if present
  if(#globalFootnotes > 0) then
    if(#globalFootnotes == 1) then 
      print('<h3>Footnote</h3><p style="' .. style .. '">')
    else
      print('<h3>Footnotes</h3><p style="' .. style .. '">')
    end
    for f=1,#globalFootnotes do
      local body = globalFootnotes[f]['body']
      -- Allow fancy links in footnotes
      -- form is @https://example.com example page@ where “example page”
      -- is the link text
      if(body:find(mc('%@(https?://%B+)%b([^%@]+)%@'))) then
       body=body:gsub(mc('%@(https?://%B+)%b([^%@]+)%@'),'<a href="%1">%2</a>')
      else
        -- Allow bare links in footnotes
        body=body:gsub(mc('(https://%B+)'),'<a href="%1">%1</a>')
      end
      body = body:gsub(mc('%*([^%*]+)%*'),'<i>%1</i>')
      -- Add footnote to page
      print(x('<a name="' .. globalFootnotes[f]['name'] .. '"> </a>'))
      print(x('<a href="#back-' .. globalFootnotes[f]['name'] .. '">' ..
            globalFootnotes[f]['link'] .. '</a>: ' .. body))
      if f<#globalFootnotes then
        print('<p style="' .. style .. '">')
      else
        print "<p>"
      end
    end
  end
end

-- Process any <a id> stuff in the HTML after processing pictures in the
-- blog. Also processes simple subscripts
function processIDetc(l)
  -- If convenient, make <a id> <a name="foo"> </a>
  -- This way the blog can have bookmarks linking directly to sections
  if l:find(mc('<h3>.*<a id="([^"]+)"[^"]*$')) then
    local thisID = l
    thisID = thisID:gsub(mc('^.*<a id="'),'')
    thisID = thisID:gsub('"[^"]*$','')
    if(globalBlogDate and globalBlogDate ~= "") then
      thisID = globalBlogDate .. '-' .. thisID
    else
      thisID = os.time() .. '-' .. thisID
    end 
    print('<a name="' .. thisID .. '"> </a>')
  end
  -- Remove <a id> stuff; it messes up the formatting of the blog on my
  -- web page
  l = l:gsub(mc('<a id[^>]+>'),'')
  l = l:gsub(mc('</a>(</h%d>)'),'%1')
  -- While we’re at it, we don’t need </p> in the document
  l = l:gsub(mc('</p>'),'')
  -- And, oh, let’s process superscripts
  -- %r is alphanumeric, including non-ASCII Xascii chars
  l = l:gsub(mc('(%r)%^(%r+)'), '%1' .. globalSupString .. "%2" .. "</sup>")
  -- htmldoc is buggy with italics in quotes
  -- \25 is ‘     \26 is ’     \29 is “     \30 is ” 
  l = l:gsub(mc('([\25\29])_(%r+)_([\29\30])'), '%1<i>%2</i>%3')
  -- Remove whitespace after <a href
  l = l:gsub(mc('(<a href=[^>]+>)%b+'),"%1")
  -- Footnotes
  if(l:find(mc('<a href=\"fn:'))) then
    local footnoteIndex = #globalFootnotes + 1
    local name = l
    name = name:gsub(mc('.*<a href=\"fn:([^<]*).*'),'%1')
    local linkText = name
    local fnText = name
    name = name:gsub('([^"]*)".*','%1')
    linkText = linkText:gsub(mc('[^>]*>%b?%^?(%B+).*$'),'%1')
    fnText = fnText:gsub(mc('[^>]*%b?%^?%B+([^<]+).*$'),'%1')
    globalFootnotes[footnoteIndex] = {}
    name = globalBlogDate .. '-' .. name
    globalFootnotes[footnoteIndex]['name'] = name
    globalFootnotes[footnoteIndex]['link'] = linkText
    globalFootnotes[footnoteIndex]['body'] = fnText
    l = l:gsub(mc('<a href=\"fn:[^>]*>[^<]*</a>'),
        globalSupString .. 
        '<a id="back-' .. name .. '">' ..
        '<a href="#' .. name .. '">' .. linkText .. '</a></a></sup>')
  end
  -- NOTE: BlogLinks.lua now handles special "blog:" links
  -- Allow italics in link text
  l = l:gsub(mc('(<a href=\"[^>]+>[^<]*)_(%r+)_'),'%1<i>%2</i>')
  -- <pre> links should not make the content too wide for a phone screen
  l = l:gsub(mc('<pre>'),'<pre class="blogPre">')
  -- htmldoc is buggy with bold text
  l = l:gsub(mc('%*%*([^*]+)%*%*'),'<b>%1</b>')
  l = l:gsub(mc('<strong></strong>([^*]+)%*%*%*?'),'<b>%1</b>')
  -- Break long words
  l = splitWideWords(l)
  -- Xascii in to UTF-8
  l = XasciiStringConvert(l)
  print(l)
end

-- After processing the picture on top of the blog, process any pictures
-- inside the blog
function processWidePic(l)
  if(l:find(mc('img alt="widepic"'))) then
    local lp = l:gsub("^%s+","")
    local fields=Split(lp,"%s+")
    if(fields[3]) then
      globalCaption = ""
      local pic = fields[3]
      pic = pic:gsub('^[^"]*"','',1)
      pic = pic:gsub('"[^"]*$','',1)
      if(#fields > 3) then
        for a=4,#fields do
          globalCaption = globalCaption .. fields[a] .. " "
        end
      end
      print('<img class=widepic src="' .. pic .. '" alt="">') 
      print('<br class=nomobile>')
      globalInWidePic = true
    end
  elseif(globalInWidePic) then
    print(XasciiStringConvert(globalCaption))
    processIDetc(l)
    globalInWidePic = false
    globalCaption = ""
  else 
    processIDetc(l)
  end
end

-- After we have filtered out all lines before the second HR NOSHADE,
-- process the line further
-- In this step, we process the image for the blog entry at the top
-- Input: A single line we are processing
-- Output: None (print called in function)
function processStep2(l)
  if(l:find(mc('img alt="blogpic"'))) then
    local lp = l:gsub("^%s+","")
    local fields=Split(lp,"%s+")
    if(fields[3]) then
      local pic = fields[3]
      pic = pic:gsub('^[^"]*"','',1)
      pic = pic:gsub('"[^"]*$','',1)
      print('<div class=blogpicx style="text-align: right">')
      print('<img src="' .. pic .. '" width=224 height=126>')
      print('</div>')
    else
      processWidePic(l)
    end
  else
    processWidePic(l)
  end 
end  

-- Convert HTML entities in to Xascii
function makeXascii(l)
  l = tostring(l)
  local state = 1
  local entity = ""
  local out = ""
  for a=1,l:len() do
    local t = l:sub(a,a)
    if x80emdash and t == '\128' then
      t = '\11'
    end
    if t == '<' and state == 1 then
      state = 2 
      out = out .. t
    elseif t == '>' and state == 2 then
      state = 1
      out = out .. t
    elseif t == '&' and state == 1 then
      state = 3
      entity = t
    elseif state == 3 and t == ';' then
      entity = entity .. t
      out = out .. entity2Xascii(entity)
      entity = ""
      state = 1
    elseif state == 3 and t == '<' then
      state = 2 -- Chop off incomplete entities
    elseif state == 3 then
      entity = entity .. t 
    elseif state == 2 then
      out = out .. t
    elseif state == 1 then
      out = out .. t
    end
  end
  return out
end

globalPlaceMarker = 0
-- Step one: Print nothing until after second HR NOSHADE
function processStep1(l) 
  l = makeXascii(l)
  l = l:gsub('%s+</a>','</a>') -- Spaces before link close look bad
  l = l:gsub('</h2>%s*<p>',"</h2>\n") -- No <p> after <h2>; legacy blog issue
  -- Do not show anything until after the *second* “HR NOSHADE”
  if globalPlaceMarker == 2 then processStep2(l) end
  if(l:find(mc("HR NOSHADE"))) then 
    globalPlaceMarker = globalPlaceMarker + 1 
  end
end

if arg[1] and arg[1] == '--test' then
  print("Running tests")
  print("This should output ÁÉÍÑÓÚÜ—•áéíóúñü¿¡→«»♥ \" ' \"")
  local i = "&Aacute;&Eacute;&Iacute;&Ntilde;&Oacute;&Uacute;&Uuml;"
  i = i .. "&mdash;&bull;&aacute;&eacute;&iacute;&oacute;&uacute;&uuml;"
  i = i .. "&iquest;&iexcl;&rarr;&laquo;&raquo;&hearts; \" ' \" "
  local Xa = makeXascii(i)
  pureASCIIoutput = false
  print(XasciiStringConvert(Xa))
  pureASCIIoutput = true
  if(XasciiStringConvert(Xa) ~= i) then
    print("XasciiStringConvert (pureASCIIoutput) failed")
    print("Expecting " .. i)
    print("Got       " .. XasciiStringConvert(Xa))
    os.exit(1)
  else
    print("XasciiStringConvert (pureASCIIoutput) pass")
  end
  os.exit(0)
end

-- This code is a fairly complicated state machine:
-- * HTML tags are always on the same line so we can process them
-- * HTML links are always on the same line so we can process them
-- * DOS linefeed characters are stripped
inLink = false
inTag = false
currentLine = ""
currentState = 0
repeat
  l = io.read(1)
  if not l then processStep1(currentLine) break end
  if l == "\r" then l = io.read(1) 
  elseif l == "\n" and not inLink and not inTag then
    processStep1(currentLine)
    currentLine = ""
  elseif l == '<' and currentState == 0 then
    inTag = true
    currentLine = currentLine .. l
    currentState = 1
  elseif l == '/' and currentState == 1 then
    currentLine = currentLine .. l
    currentState = 100
  -- Process end of links
  elseif l == 'a' and currentState == 100 then
    currentLine = currentLine .. l
    currentState = 101
  elseif l == '>' and currentState == 101 then
    currentLine = currentLine .. l
    currentState = 102
    inLink = false
    inTag = false
  elseif l == '<' and currentState == 102 then
    currentLine = currentLine .. l
    currentState = 1
    inTag = true
  elseif l:find('%S') and currentState == 102 then
    currentLine = currentLine .. l
  elseif l:find('%s') and currentState == 102 then
    currentState = 0
    processStep1(currentLine)
    currentLine = ""
  -- Process h2 tags
  elseif l == 'h' and currentState == 100 then
    currentLine = currentLine .. l
    currentState = 200
  elseif l == '2' and currentState == 200 then
    currentLine = currentLine .. l
    currentState = 201
  elseif l == '>' and currentState == 201 then
    currentLine = currentLine .. l
    currentState = 0
    inTag = true -- Keep this true so the subsequent <p> is on same line
  elseif l == 'a' and currentState == 1 then
    currentLine = currentLine .. l
    currentState = 2
  elseif l:find('%s') and currentState == 2 then
    currentLine = currentLine .. ' '
  elseif l == 'h' and currentState == 2 then
    currentLine = currentLine .. l
    currentState = 3
  elseif l == 'r' and currentState == 3 then
    currentLine = currentLine .. l
    currentState = 4
  elseif l == 'e' and currentState == 4 then
    currentLine = currentLine .. l
    currentState = 5
  elseif l == 'f' and currentState == 5 then
    currentLine = currentLine .. l
    currentState = 6
  elseif l == '=' and currentState == 6 then
    currentLine = currentLine .. l
    currentState = 0
    inLink = true
  elseif l == "\n" and inLink then
    currentLine = currentLine .. ' '
  elseif l == "\n" and inTag then
    currentLine = currentLine .. ' '
  elseif l == '>' then
    inTag = false
    currentLine = currentLine .. l
    currentState = 0
  elseif l then
    currentLine = currentLine .. l
    currentState = 0
  end
until not l

-- Show any remaining footnotes
processFootnotes()

-- Footer
if not blogFooter then os.exit(0) end
print ""
print "<p>"
--print ""
--print "<A href=/blog/>Blog index</A>"
print ""
print "</div>"
print ""
