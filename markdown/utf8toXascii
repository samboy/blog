#!/bin/sh
_rem=--[=[
# POSIX shell wrapper to call correct version of Lua or Lunacy

LUNACY=""
if command -v lunacy64 >/dev/null 2>&1 ; then
  LUNACY=lunacy64
elif command -v lua5.1 >/dev/null 2>&1 ; then
  LUNACY=lua5.1
elif command -v lua-5.1 >/dev/null 2>&1 ; then
  LUNACY=lua-5.1
elif command -v lunacy >/dev/null 2>&1 ; then
  LUNACY=lunacy
elif command -v luajit >/dev/null 2>&1 ; then
  LUNACY=luajit # I assume luajit will remain frozen at Lua 5.1
fi
if [ -z "$LUNACY" ] ; then
  echo Please install Lunacy or Lua 5.1
  echo Either the version included with this blog -or- the version at
  echo https://github.com/samboy/lunacy
  echo To compile and install the version of Lunacy with the blog:
  echo
  echo     tar xvJf lunacy-2022-12-06.tar.xz
  echo     cd lunacy-2022-12-06/
  echo     make
  echo     sudo cp lunacy /usr/local/bin/
  exit 1
fi

exec $LUNACY $0 "$@"

# ]=]1
-- This script is written in Lua 5.1

-- This script has been donated to the public domain in 2025 by Sam Trenholme
-- If, for some reason, a public domain declation is not acceptable, it
-- may be licensed under the following terms:

-- Copyright 2025 Sam Trenholme
-- Permission to use, copy, modify, and/or distribute this software for
-- any purpose with or without fee is hereby granted.
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
-- WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
-- OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

-- Let’s convert a UTF-8 character in to a low-bit control character
-- This uses obscure ASCII characters (Nul, \t, \n, \f, \r, and Esc
-- keep their meta-meeting) so that each character is 8 bits wide for
-- regex parsing etc.

-- Note that “—” becomes a character which the Lua regex expression
-- "%s" sees as a space character ("%s" simply uses the C language 
-- isspace() function). If — needs to be treated like a non-space,
-- match against '[\9\10\12\13\32]' for spaces.

function utf8toXascii(glyph)
  local g={}
  --[[ NUL ]]    g["Á"] = '\1'  g["É"] = '\2'  g["Í"] = '\3' 
  g["Ñ"] = '\4'  g["Ó"] = '\5'  g["Ú"] = '\6'  g["Ü"] = '\7'
  g["¡"] = '\8'  --[[ \t ]]     --[[ \n ]]     g["—"] = '\11'
  --[[ \f ]]     --[[ \r ]]     g["«"] = '\14' g["»"] = '\15'
  g["•"] = '\16' g["á"] = '\17' g["é"] = '\18' g["í"] = '\19'
  g["ñ"] = '\20' g["ó"] = '\21' g["ú"] = '\22' g["ü"] = '\23'
  g["¿"] = '\24' g["‘"] = '\25' g["’"] = '\26' --[[ ESC ]]
  g["→"] = '\28' g["“"] = '\29' g["”"] = '\30' g["©"] = '\31'
  g["♥"] = '\127'

  if g[glyph] then return g[glyph] end
  return nil
end

glyph = ''
l = true
while l do
  l = io.read(1)
  if not l then break end
  value = l:byte()
  if(value >= 128 and value < 192) then
    glyph = glyph .. l
  elseif(value >= 192 and glyph == '') then
    glyph = l
  else
    x = utf8toXascii(glyph)
    if x then io.write(x) elseif glyph:len() > 0 then io.write("\11") end
    if(value < 128) then
      glyph = ''
      io.write(l)
    else
      glyph = l
    end
  end
end

x = utf8toXascii(glyph)
if x then io.write(x) elseif glyph:len() > 0 then io.write("\11") end
